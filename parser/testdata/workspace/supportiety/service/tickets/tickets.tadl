context worldiety::ApplicationSupport::ErrorTracking::Ticket {
        core {

            # ...represents a data entity and this sentence must be in ellipsis summary form.
            # = A Title is actually parsed as AST DocTitle and optional.
            # Another arbitrary " \n text
            #
            # if something starts with '# see' the following tokens are parsed as a Path
            # see requirements::tickets::ManageTickets
            # see glossary::Ticket
            struct Ticket {

                # ...is the entities unique identifier.
                # see requirements::tickets::ManageTickets
                # see glossary::Ticket
                ID string

                # ...is a duplicate and will fail later.
                ID mytext::ExternalString

                # ...shows how to use a sub domain type as a pointer.
                Tasks1 *tickets::domain::tasks::core::Task

                # ...shows a slice example, using [] would require sonderlocke.
                Tasks2 slice<string!>

                # ...shows a nested slice example.
                KeyVal map<int,slice!<tickets::domain::tasks::core::Task>>

            }

            # ...declares a repository interface.
            repository Tickets {
                # ...searches all the things.
                # == Parameters
                # * x ...is a secret.
                # * b ...is another secret.
                # * sadly I could lie about everything, must validate later.
                FindAll(x str, b str) -> (Task)

                # ...searches all the things.
                # == Returns
                # A new Task which represents stuff to do.
                #
                # == Errors
                # * NotFound ...is returned if that guy has not been found.
                # * Other ...is returned if anything else went wrong.
                #   Totally unspecified.
                # * RuntimeException ...is not validated either.
                FindAll2(x str, b str) -> (Task, error<NotFound|Other>)
            }

            # ...declares a service which is always a singleton and created at application creation time.
            service TicketService {
                // configure is optional and creates a configuration struct and results in a member.
                configure {
                    # ...turns a flag on or off and is injected at construction time.
                    FeatureFlag bool = false

                    # ...turns a flag on or off and is injected at construction time.
                    FeatureFlag2 bool = true
                }

                // inject is optional and can only ever refer to interface-types (e.g. repository) within core.
                inject {
                    # ...results in the according member.
                    repo Tickets
                }

                // private declares other private fields.
                private {
                    # ...protects the cache.
                    lock sync::Mutex

                    # ...caches some stuff and is prone to race conditions.
                    cache map!<string,string>
                }



                # ...performs some domain specific validation and delegates to the repo.
                PerformValidation(x str, b str) -> (Task)
            }


        }

       usecase {
            # ...groups all ticket related use cases.
            service WithTickets {
                inject {
                    # ...the core domain service to use. This may be non-interface but may also use repos directly.
                    # However, only domain core elements are allowed.
                    tickets *tickets::core::TicketService
                }
            }
        }

}






