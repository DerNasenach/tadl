= markup
:source-highlighter: highlight.js
:highlightjs-languages: asciidoc, abnf
:toc:
Torben Schinke

Oh no, not yet another markup.

== Motivation

Common markup languages:

 * SGML
 ** XML
 ** HTML
 * ...

Common lightweight markup languages:

 * Markdown
 * AsciiDoc
 * ...

Common Data exchange formats:

 * JSON
 * YAML
 * TOML
 * ...

So what is wrong with that?

 * SGML variants are verbose and hard to read for non-developers. Complex XML with XML-Schemas and self declaring
   definitions cannot be handwritten anymore, like ReqIF or OpenXML.
 * lightweight markup languages are underspecified and usually not even properly parseable.
 * data exchange formats are more or less verbose. Due to missing markup
  they are generally unsuited for raw text segments and require a lot of escaping and extra
  notations of elements to express sibling and children nodes.

A good starting point, which explains what is wrong with the omnipresent Markdown is
here https://docs.asciidoctor.org/asciidoc/latest/asciidoc-vs-markdown/.

A good starting point, which explains what is wrong with AsciiDoc is luckily documented by the project
itself:

 * https://docs.asciidoctor.org/asciidoc/latest/text/troubleshoot-unconstrained-formatting/
 * https://github.com/asciidoctor/asciidoctor/issues/61#issuecomment-373576992
 * https://github.com/asciidoctor/asciidoctor/issues/901
 * https://github.com/asciidoctor/asciidoctor/issues/61#issuecomment-373554218

== Approach

The idea of XML is good to express markup which can be parsed unambiguously. So copy that but let us
make XML simpler:

* Remove attribute nodes (x="abc").
* Remove verbose repetition of closing declaration (</elem>).
* Remove redundant node closing characters (>).
* Remove namespaces, different charsets, cdata, preamble, entities, processing directive.
* Remove redundant document root element.
* Introduce some rules to automatically express nesting without the need of explicit declaration.

== Specification

The text encoding is always UTF-8. In general, each valid markup can be lossless transformed into XML.
The lexer grammar is defined as follows and can be toggled between two lexer/parsers:

Lexer 1
[source,abnf]
----
Comment       =  #?
Attribute     =  #: <Element> TextNode
Element       =  #[^(\s|#|{|}|!)]+
SwitchToLex2  =  #!
Shift         =  # <Element>
Block         =  <Element> ({ (Element|TextNode)* })?
TextNode      =  !<Element>
escape        =  \# | \}
----

Lexer 2
[source,abnf]
----
Comment              =  #?
Element              =  [^(\s|#|{|}|!)]+
ForwardAttribute     =  @ Element TextNode | TextNodeLine
SwitchToLex1         =  #!
NoNesting            =  ,
TextNodeLine         =  #
Block                =  <Element> ({ (Element|TextNode)* })?
TextNode             =  "(\\"|[^"])*"
escape               =  \"
----

All document elements are implicitly wrapped by a root element without a name. An element is always declared by a prefixed
#. All other hashtags must be escaped using backslash. Braces can be omitted and are inserted automatically. The
closing bracket is either inserted directly before the next element declaration or after a shifted element declaration.

=== Examples

==== Example 1
A comment, an Element and an escaped TextNode.
[source,tadl]
----
#? this is a comment
#HelloNode
\#A Text
#Other #:attribute some random text until next hash
----

Transforms to:

[source,xml]
----
<root>
    <!-- this is a comment -->
    <HelloNode/>
    #A Text
    <Other attribute="some random text until next hash"/>
</root>
----

==== Example 2
Some nested Elements.

[source,tadl]
----
#book {
  #toc
  #section {
    #title {
        The sections title
    }

    The sections text.
  }
}
----

Is equal to the following notation with automatic brace insertion rules:

[source,tadl]
----
#book ##toc ##section

##title{The sections title}

The sections text.
----

A single # closes the brace before the element and a double ## closes the brace after the element, unless
another double # is found or closed explicitly with #!:

[listing]
#book ##toc ##section         => #book{ #toc{ #section{
##title{The sections title}   => #title{The sections title}
The sections text.            => The sections text.
EOF                           => } } }

Transforms to:

[source,xml]
----
<root>
    <book>
        <toc/>
        <section>
            <title>The sections title</title>
            The sections text.
        </section>
    </book>
</root>
----

==== Example 3
Line and formatting invariance.

[source,tadl]
----
#book {
 #section {
   #title {
      hello section
   }
   This is the #em{section} text.
 }
}
----

is equivalent to

[source,tadl]
----
#book{#section{#title{hello section}This is the #em{section} text.}}
----

is equivalent to

[source,tadl]
----
#book ##section ##title {hello section}
This is the #em{section} text.
----

==== Example 4
The parser can be toggled between two modes (more markup or more text),
so a writer can decide which reads best in the current context.

[source,tadl]
----
#list{
  #item1{#key value}
  #item2
  #item3
}
----

is equivalent to
[source,tadl]
----
#!
list{
    item1 key "value",
    item2,
    item3,
}
----

==== Example 5
Declaring and documenting types.

[source,tadl]
----
    A Ticket represents a piece of
    paper with things to do.
    #struct ##Ticket {
        ID is the unique identifier.
        #ID uuid

        Message contains some text to read.
        #Message string
    }

    ... provides CRUD access functions for #ref{Ticket} entities.
    #interface ##Repository {
        ...selects a single entry.
        #FindOne{#id uuid} #-> {#Ticket #error}

        ...searches all the things.
        #FindAll{#offset int32 #limit int32} #-> {#[]##Ticket #error}
    }

    #! "...switch the parser"
    @info "this is a forward attribute and never inline block as the other parser does"
    interface Repository2 {
        # ...selects a single entry.
        param limit "indicates some limit"
        FindAll{offset int32, @max "5" limit int32} -> {[]Ticket, error}
    }

----

Transforms to:

[source,xml]
----
<root>
    A Ticket represents a piece of
    paper with things to do.
    <struct>
        <Ticket>
            ID is the unique identifier.
            <ID>uuid</ID>

            Message contains some text to read.
            <Message>string</Message>
        </Ticket>
    </struct>

    ... provides CRUD access functions for #ref{Ticket} entities.
    <interface>
        <Repository>
            ...selects a single entry.
            <FindOne>
                <id>uuid</id>
            </FindOne>
            <RETURNS> <!-- #-> -->
                <Ticket/>
                <error/>
            </RETURNS>

            ...searches all the things.
            <FindAll>
                <offset>int32</offset>
                <limit>int32</limit>
            </FindAll>
             <RETURNS> <!-- #-> -->
                <SLICE> <!-- [] -->
                    <Ticket/>
                </SLICE>
                <error/>
            </RETURNS>
        </Repository>
    </interface>

    <interface info="this is a forward attribute and never inline block as the other parser does">
        ...switch the parser
        <Repository2>
            ...selects a single entry.
            <param><limit>indicates some limit</limit></param>
            <FindAll>
                <offset><int32/></offset>
                <limit max="5"><int32/></limit>
            </FindAll>

            <RETURNS> <!-- #-> -->
                <SLICE> <!-- [] -->
                    <Ticket/>
                </SLICE>
                <error/>
            </RETURNS>

        </Repository2>
    </interface>
</root>
----


### Brainstorming 1

Incompatible attribute notation, where the attributes value can contain other nodes as well => attributes is a unique
section of key=value stuff (the json/yaml compatible part?). The nested node stuff is the xml-only part?

[source]
----
#!
@doc "...is the \"type\" documentation"
type Person struct {
    @doc "...is the first name"
    @param ????
    Firstname int32
}
----

[source,xml]
----
<type doc="...is the &quot;type&quot; documentation">
    <Person>
        <struct>
            <Firstname doc="...is the first name">
                <int32/>
            </Firstname>
        </struct>
    </Person>
</type>
----

### Brainstorming 2
There are no attributes, but a notation to _upsert_ or _merge_ one element into another, instead of appending
the entire element as new. This can be done using the @ forward declaration in Parser2:

[source]
----
#!(
    @doc "...is the \"type\" documentation"
    @doc # appends "it"
    type Person struct {
        @doc "...is the first name"
        Firstname int32

        @doc "...gets some"
        @param Firstname # ...is the field of choice
        func Get{stuff string, other []int}
    }
)
----

[source,xml]
----
<type doc="...is the &quot;type&quot; documentation">
    <doc>
    ...is the "type" documentation
    appends "it"
    </doc>
    <Person>
        <struct>
            <Firstname>
                <doc>...is the first name</doc>
                <int32/>
            </Firstname>

            <func>
                <doc>...gets some</doc>
                <param>
                    <Firstname>...is the field of choice</Firstname>
                </param>
                <Get>
                    <stuff><string/></stuff>
                    <other>
                        <SLICE><int/></SLICE>
                    </other>
                </Get>
            </func>
        </struct>
    </Person>
</type>
----
