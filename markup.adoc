= markup
:source-highlighter: highlight.js
:highlightjs-languages: asciidoc, abnf
:toc:
Torben Schinke

This article proposes a new general purpose markup language,
which can be used to write texts but also allows to efficiently express domain specific languages.

== Motivation

=== Why not HTML?
HTML was neither designed for print nor for building DSLs. Even, as of today and the according print media query,
there are a lot of shortcomings, like proper typesetting, page breaks or even page numberings.

=== Why not XML (or formats using it, like DocBook)?
XML as a standard is very complex. Self-contained descriptions like Req-If or OOXML are actually impossible to be
written by hand. Also, it is very verbose by design. DSLs are impossible to express in a readable way. When
thinking about it, it is astonishing how successful XML became, despite it is hard to be read by humans and
even hard and expensive to process.

=== Why not Markdown?
The actual Markdown standard is pretty small and does not even contain things like footnotes or tables. Therefore,
a lot of incompatible flavors have been created. Also, there is an obvious focus on HTML transformation.

=== Why not AsciiDoc?
There is no context free grammar, which makes it hard to parse. Besides the reference implementation, there is not
even a specification. It looks like, that one needs more than https://github.com/asciidoctor/asciidoctor/issues/61#issuecomment-373576992[64 parsers] to build an AST. There are other edge cases
which cannot be fixed, like proper https://github.com/asciidoctor/asciidoctor/issues/901[escaping]. These bugs
are unaddressed since more than 8 years now. Others try to create parsers for it, e.g. by using
https://github.com/bytesparadise/libasciidoc[PEG Parsers], which results in parsers with more than 64 thousand lines
of code and still fails to support even the most basic https://github.com/bytesparadise/libasciidoc/issues/290[features].

=== Why not another lightweight markup language?
It looks like that there are more than 20 popular ones. I only did a superficial check of their syntax, but all them seem to fall short, when it comes to arbitrary complexity and unambiguous parsing.

=== Why not JSON, YAML, TOML or others?
Non-markup formats are not suited for mixing text and annotated text fragments (well, markup). If one has to express
that with an object notation format, you need to create recursive holder objects and a lot of escaping. It is not
feasible to write this by hand.

== Approach

The core idea of XML, to have text with markup which can be parsed unambiguously, is really great.
So lets keep that idea but remove complexity:

* Remove verbose repetition of closing declaration (</elem>).
* Remove redundant node closing characters (>).
* Remove namespaces, different charsets, cdata, preamble, entities, processing directive.
* Remove redundant document root element.
* Introduce some rules to automatically express nesting without the need of explicit declaration.

== Specification

The text encoding is always UTF-8. In general, each valid markup can be lossless transformed into XML
but not the other way round.
There are two grammars, which express both the same structures but have both clear tradeoffs.
The default grammar is suited for _text first_ content, so the writer can focus on his natural
language and enrich it with markup declarations. The second grammar is _node first_ and avoids
all # markers for nodes.

Grammar 1 (text first)
[source,abnf]
----
Char              ::=  \\(#|})|[^(#|})]                     // anything but unescaped # and }
S                 ::=  \s                                   // any whitespace

CommentNode       ::=  '#?' S* '{' Char* '}'                // multiline
CommentLine       ::=  '#?' Char* '\n'                      // anything until end of line

Grammar2          ::= '#!' S* '{' .* '}'                    // { } pairs must be balanced inside .*

Element           ::= '#' Identifier S* Attribute* S* '{' (Element|Text)* '}'
Identifier        ::= [^(\s|#|{|}|!|@)]+                    // anything but #, {, }, !, @, ' ' and at least one char

Attribute         ::= '##' Identifier S* '{' Char '}'       // attributes can only have texts
AttributeID       ::= '##' S* '{' Char '}'                  // alias

Accessor          ::= '#@' Identifier S* Attribute* S* '{' (Element|Text)* '}' // fails, if no such element has been declared yet

// Scanner insertion rules:
// Rule 1: If after consuming ('#' Identifier S*) and there is no '{' insert '{' before continue
// Rule 2: If after consuming ('#' Identifier S* '{') and there is a # (but not a ##), insert '{' before the #
// Rule 3: (## S*) is replaced with (##id S*)
----

Lexer 2
[source,abnf]
----
Comment              =  #?
Element              =  [^(\s|#|{|}|!|@)]+
ForwardAttribute     =  @ Element TextNode | TextNodeLine
SwitchToLex1         =  #!
NoNesting            =  ,
TextNodeLine         =  #
Block                =  <Element> ({ (Element|TextNode)* })?
TextNode             =  "(\\"|[^"])*"
escape               =  \"
----

All document elements are implicitly wrapped by a root element without a name. An element is always declared by a prefixed
#. All other hashtags must be escaped using backslash. Braces can be omitted and are inserted automatically. The
closing bracket is either inserted directly before the next element declaration or after a shifted element declaration.

=== Examples

==== Example 1
A comment, an Element and an escaped TextNode.
[source,tadl]
----
#? this is a comment
#HelloNode
\#A Text
#Other #:attribute some random text until next hash
----

Transforms to:

[source,xml]
----
<root>
    <!-- this is a comment -->
    <HelloNode/>
    #A Text
    <Other attribute="some random text until next hash"/>
</root>
----

==== Example 2
Some nested Elements.

[source,tadl]
----
#book {
  #toc
  #section {
    #title {
        The sections title
    }

    The sections text.
  }
}
----

Is equal to the following notation with automatic brace insertion rules:

[source,tadl]
----
#book ##{einfaches buch} {
    #title Ein sehr einfaches buch
    #chapter ##{einfaches kapitel} {
        #title Kapitel
        #para Hallo Welt!
    }
}

#@{einfaches buch}{
    #chapter ##id{zweites kapitel} {

    }
}

<book id="einfaches_buch">
    <title>Ein sehr einfaches Buch</title>
    <chapter id="einfaches_kapitel">
        <title>Kapitel</title>
        <para>Hallo Welt!</para>
    </chapter>
</book>

#section{The sections title}
The sections text.
#image{#width{0.5} https://worldiety.de/logo.png}

#subsection{The subsections title}
The #red{sections} text.

##section/title{The sections title}
The sections text.
----

A single # closes the brace before the element and a double ## closes the brace after the element, unless
another double # is found or closed explicitly with #!:

[listing]
#book ##toc ##section         => #book{ #toc{ #section{
##title{The sections title}   => #title{The sections title}
The sections text.            => The sections text.
EOF                           => } } }

Transforms to:

[source,xml]
----
<root>
    <book>
        <toc/>
        <section>
            <title>The sections title</title>
            The sections text.
        </section>
    </book>
</root>
----

==== Example 3
Line and formatting invariance.

[source,tadl]
----
#book {
 #section {
   #title {
      hello section
   }
   This is the #em{section} text.
 }
}
----

is equivalent to

[source,tadl]
----
#book{#section{#title{hello section}This is the #em{section} text.}}
----

is equivalent to

[source,tadl]
----
#book ##section ##title {hello section}
This is the #em{section} text.
----

==== Example 4
The parser can be toggled between two modes (more markup or more text),
so a writer can decide which reads best in the current context.

[source,tadl]
----
#list{
  #item1{#key value}
  #item2
  #item3
}
----

is equivalent to
[source,tadl]
----
#!
list{
    item1 key "value",
    item2,
    item3,
}
----

==== Example 5
Declaring and documenting types.

[source,tadl]
----
    A Ticket represents a piece of
    paper with things to do.
    #struct ##Ticket {
        ID is the unique identifier.
        #ID uuid

        Message contains some text to read.
        #Message string
    }

    ... provides CRUD access functions for #ref{Ticket} entities.
    #interface ##Repository {
        ...selects a single entry.
        #FindOne{#id uuid} #-> {#Ticket #error}

        ...searches all the things.
        #FindAll{#offset int32 #limit int32} #-> {#[]##Ticket #error}
    }

    #! "...switch the parser"
    @info "this is a forward attribute and never inline block as the other parser does"
    interface Repository2 {
        # ...selects a single entry.
        param limit "indicates some limit"
        FindAll{offset int32, @max "5" limit int32} -> {[]Ticket, error}
    }

----

Transforms to:

[source,xml]
----
<root>
    A Ticket represents a piece of
    paper with things to do.
    <struct>
        <Ticket>
            ID is the unique identifier.
            <ID>uuid</ID>

            Message contains some text to read.
            <Message>string</Message>
        </Ticket>
    </struct>

    ... provides CRUD access functions for #ref{Ticket} entities.
    <interface>
        <Repository>
            ...selects a single entry.
            <FindOne>
                <id>uuid</id>
            </FindOne>
            <RETURNS> <!-- #-> -->
                <Ticket/>
                <error/>
            </RETURNS>

            ...searches all the things.
            <FindAll>
                <offset>int32</offset>
                <limit>int32</limit>
            </FindAll>
             <RETURNS> <!-- #-> -->
                <SLICE> <!-- [] -->
                    <Ticket/>
                </SLICE>
                <error/>
            </RETURNS>
        </Repository>
    </interface>

    <interface info="this is a forward attribute and never inline block as the other parser does">
        ...switch the parser
        <Repository2>
            ...selects a single entry.
            <param><limit>indicates some limit</limit></param>
            <FindAll>
                <offset><int32/></offset>
                <limit max="5"><int32/></limit>
            </FindAll>

            <RETURNS> <!-- #-> -->
                <SLICE> <!-- [] -->
                    <Ticket/>
                </SLICE>
                <error/>
            </RETURNS>

        </Repository2>
    </interface>
</root>
----


### Brainstorming 1

Incompatible attribute notation, where the attributes value can contain other nodes as well => attributes is a unique
section of key=value stuff (the json/yaml compatible part?). The nested node stuff is the xml-only part?

[source]
----
#!
@doc "...is the \"type\" documentation"
type Person struct {
    @doc "...is the first name"
    @param ????
    Firstname int32
}
----

[source,xml]
----
<type doc="...is the &quot;type&quot; documentation">
    <Person>
        <struct>
            <Firstname doc="...is the first name">
                <int32/>
            </Firstname>
        </struct>
    </Person>
</type>
----

### Brainstorming 2
There are no attributes, but a notation to _upsert_ or _merge_ one element into another, instead of appending
the entire element as new. This can be done using the @ forward declaration in Parser2:

[source]
----
#!(
    @doc "...is the \"type\" documentation"
    @doc # appends "it"
    type Person struct {
        @doc "...is the first name"
        Firstname int32

        @doc "...gets some"
        @param Firstname # ...is the field of choice
        func Get{stuff string, other []int}
    }
)
----

[source,xml]
----
<type doc="...is the &quot;type&quot; documentation">
    <doc>
    ...is the "type" documentation
    appends "it"
    </doc>
    <Person>
        <struct>
            <Firstname>
                <doc>...is the first name</doc>
                <int32/>
            </Firstname>

            <func>
                <doc>...gets some</doc>
                <param>
                    <Firstname>...is the field of choice</Firstname>
                </param>
                <Get>
                    <stuff><string/></stuff>
                    <other>
                        <SLICE><int/></SLICE>
                    </other>
                </Get>
            </func>
        </struct>
    </Person>
</type>
----
