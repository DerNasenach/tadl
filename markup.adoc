= markup
:source-highlighter: highlight.js
:highlightjs-languages: asciidoc, abnf
:toc:
Torben Schinke

This article proposes a new general purpose markup language,
which can be used to write texts but also allows to efficiently express domain specific languages.

== Motivation

=== Why not HTML?
HTML was neither designed for print nor for building DSLs. Even, as of today and the according print media query,
there are a lot of shortcomings, like proper typesetting, page breaks or even page numberings.

=== Why not XML (or formats using it, like DocBook)?
XML as a standard is very complex. Self-contained descriptions like Req-If or OOXML are actually impossible to be
written by hand. Also, it is very verbose by design. DSLs are impossible to express in a readable way. When
thinking about it, it is astonishing how successful XML became, despite it is hard to be read by humans and
even hard and expensive to process.

=== Why not Markdown?
The actual Markdown standard is pretty small and does not even contain things like footnotes or tables. Therefore,
a lot of incompatible flavors have been created. Also, there is an obvious focus on HTML transformation.

=== Why not AsciiDoc?
There is no context free grammar, which makes it hard to parse. Besides the reference implementation, there is not
even a specification. It looks like, that one needs more than https://github.com/asciidoctor/asciidoctor/issues/61#issuecomment-373576992[64 parsers] to build an AST. There are other edge cases
which cannot be fixed, like proper https://github.com/asciidoctor/asciidoctor/issues/901[escaping]. These bugs
are unaddressed since more than 8 years now. Others try to create parsers for it, e.g. by using
https://github.com/bytesparadise/libasciidoc[PEG Parsers], which results in parsers with more than 64 thousand lines
of code and still fails to support even the most basic https://github.com/bytesparadise/libasciidoc/issues/290[features].

=== Why not another lightweight markup language?
It looks like that there are more than 20 popular ones. I only did a superficial check of their syntax, but all them seem to fall short, when it comes to arbitrary complexity and unambiguous parsing.

=== Why not JSON, YAML, TOML or others?
Non-markup formats are not suited for mixing text and annotated text fragments (well, markup). If one has to express
that with an object notation format, you need to create recursive holder objects and a lot of escaping. It is not
feasible to write this by hand.

== Approach

The core idea of XML, to have text with markup which can be parsed unambiguously, is really great.
So lets keep that idea but remove complexity:

* Remove verbose repetition of closing declaration (</elem>).
* Remove redundant node closing characters (>).
* Remove namespaces, different charsets, cdata, preamble, entities, processing directive.
* Remove redundant document root element.
* Introduce some rules to automatically express nesting without the need of explicit declaration.

== Specification

The text encoding is always UTF-8. In general, each valid markup can be lossless transformed (besides exact whitespace)
into XML but not the other way round.
There are two grammars, which express both the same structures but have both clear tradeoffs.
The default grammar is suited for _text first_ content, so the writer can focus on his natural
language and enrich it with markup declarations. All white-spaces within an elements block are
significant, because their rendering depends on later transformation and styling
(see also the white-space processing model of https://drafts.csswg.org/css-text-3/#white-space-phase-1[html5/CSS]).

Grammar 1 (text first)
[source,abnf]
----
// anything but unescaped # and }
Char              ::=  \\(#|})|[^(#|})]
Text              ::=  Char*
// any whitespace
S                 ::=  \s

// multiline
CommentNode       ::=  '#?' S* '{' Char* '}'
// anything until end of line
CommentLine       ::=  '#?' Char* '\n'

// { } pairs must be balanced inside .*, other symbols are ignored
Grammar2          ::= '#!' S* '{' .* '}'

Element           ::= '#' Identifier S* Attribute* S* '{' (Element|Text)* '}'
// until next # or }
ShortElement      ::= '#' '@'? Identifier S* Attribute* Text*
// anything but #, {, }, !, @, ' ' and at least one char
Identifier        ::= [^(\s|#|{|}|!|@)]+

// attributes can only have texts, id-value must be unique
Attribute         ::= '##' Identifier S* '{' Char '}'

// id must exist and conform to Identifier
Accessor          ::= '#@' Identifier S* Attribute* S* '{' (Element|Text)* '}'

// Scanner insertion rules:
// Rule 1: If after consuming ('#' Identifier S*) and there is no '{' insert '{' before scanning next
// Rule 2: If after consuming ('#' Identifier S* '{') and there is a # (but not a '##'), insert '{' before the '#'
// Rule 3: ('#:' Identifier) is replaced with ('##id' S*)
//
/// Whitespace significance rules:
// Rule 1: Any whitespace within an Element is significant
// Rule 2: Whitespace between terminator symbols are insignificant

----

The second grammar is _node first_ and avoids all # markers for nodes for the price of escaping text content.
It must be declared within '#! {' '}'.

Grammar 2 (node first):
[source,abnf]
----
// anything but #, {, }, !, @, ' ' and at least one char
Identifier          ::= [^(\s|#|{|}|!|@)]+

// uninterpreted string enclosed in "
String              ::=  "(\\"|[^"])*"

// create new and append element to last Element
Element             ::= Identifier

// close element, subsequent declared elements are added to prior parent
CloseElement        ::= ','

// An entire line can be marked as Grammar1 (must not contain recursive Grammar 2)
Grammar1Line        ::= '# ' .*

// Like Grammar1Line but the Text is inserted into the next declared element, instead the current position.
ForwardGrammar1Line ::= '#@ ' .* '\n' S* Element

// Attribute to set on the enclosing Element
Attribute           ::= '@' Identifier S* '=' S* String

// Attribute to set on the next declared element, instead the current one.
ForwardAttribute     =  '@' Identifier S* '=' S* String

----

All document elements are implicitly wrapped by a root element without a name. An element is always declared by a prefixed
#. All other hashtags must be escaped using backslash. Braces can be omitted and are inserted automatically. The
closing bracket is either inserted directly before the next element declaration or after a shifted element declaration.

=== Examples

==== Example 1
A simple hello world
[source,tadl]
----
#? saying
   hello world

#hello{world}
----

Transforms to:

[source,xml]
----
<root>
<!-- saying
     hello world

-->
<hello>world</hello>
</root>
----

==== Example 2
A book example.

[source,tadl]
----
#book {
  #toc{}
  #section #:1 {
    #title {
        The sections title
    }

    The sections text.
  }
}
----

Is equal to the following notation (including white space):

[source,tadl]
----
#book {
  #toc
  #section #:1 {
    #title {
        The sections title
    }

  }
}

#@1 {
    The sections text.
}
----

Transforms to (some whitespace indents may vary):

[source,xml]
----
<root>
    <book>
        <toc/>
        <section id="1">
            <title>
                The sections title
            </title>

            The sections text.
        </section>
    </book>
</root>
----

==== Example 3
A more complex book example, could be a DocBook.

[source,tadl]
----
#book #:my-book ##author Torben {
    #title A very simple book
    #chapter #:ch1
    #chapter #:ch2
}

#@ch1 {
    #title Chapter One
    #p Hello paragraph.
    Still going on.
}

#@ch2 {
    #title Chapter Two
    Some #red{#bold Text} text.
    The #span ##style{color:red} { #span ##style{font-weight:bold} Text } text.
    #image ##width{100%} https://worldiety.de/favicon.png
}
----

Transforms to (some whitespace indents may vary):

[source,xml]
----
<root>
    <book id="my-book" author="Torben">
        <title>A very simple book</title>
        <chapter id="ch1">
            <title>Chapter One</title>
            <p>Hello paragraph.
            Still going on.</p>
        </chapter>

        <chapter id="ch2">
            <title>Chapter Two</title>
            Some <red><bold>Text</bold></red> text.
            The <span style="color:red"><span style="font-weight:bold">Text </span></span> text.
            <image width="100%">https://worldiety.de/favicon.png</image>
        </chapter>
    </book>
</root>
----



==== Example 4
The parser can be toggled between two modes (more markup or more text),
so a writer can decide which reads best in the current context.

[source,tadl]
----
#list{
  #item1{#key value}
  #item2
  #item3
}
----

is equivalent to
[source,tadl]
----
#!{
    list{
        item1 key "value",
        item2 @1,
        item3 @key="value",
    }
}
----

Transforms to (some whitespace indents may vary):
[source,xml]
----
<root>
   <list>
        <item1><key>value</key></item1>
        <item2 id="1"/>
        <item3 key="value"/>
   </list>
</root>
----

### Brainstorming 2
There are no attributes, but a notation to _upsert_ or _merge_ one element into another, instead of appending
the entire element as new. This can be done using the @ forward declaration in Parser2:

[source]
----
#!(
    #@ This is a forward #ref{someid} text node on type with non-recursive grammar 1.
    @@doc "...is a forward attribute \"type\" documentation"
    type Person struct {
        # this is #bold{another} non-recursive grammar 1 line
        @@field "...is the first name"
        Firstname int32

        #@ ...gets some
        @@stuff "go for it"
        @@other "is the field of choice"
        func Get{stuff string, other []int}
    }
)
----

[source,xml]
----
<type doc="...is the &quot;type&quot; documentation">
    <doc>
    ...is the "type" documentation
    appends "it"
    </doc>
    <Person>
        <struct>
            <Firstname>
                <doc>...is the first name</doc>
                <int32/>
            </Firstname>

            <func>
                <doc>...gets some</doc>
                <param>
                    <Firstname>...is the field of choice</Firstname>
                </param>
                <Get>
                    <stuff><string/></stuff>
                    <other>
                        <SLICE><int/></SLICE>
                    </other>
                </Get>
            </func>
        </struct>
    </Person>
</type>
----




==== Example 5
Declaring and documenting types.

[source,tadl]
----
    A Ticket represents a piece of
    paper with things to do.
    #struct ##Ticket {
        ID is the unique identifier.
        #ID uuid

        Message contains some text to read.
        #Message string
    }

    ... provides CRUD access functions for #ref{Ticket} entities.
    #interface ##Repository {
        ...selects a single entry.
        #FindOne{#id uuid} #-> {#Ticket #error}

        ...searches all the things.
        #FindAll{#offset int32 #limit int32} #-> {#[]##Ticket #error}
    }

    #! "...switch the parser"
    @info "this is a forward attribute and never inline block as the other parser does"
    interface Repository2 {
        # ...selects a single entry.
        param limit "indicates some limit"
        FindAll{offset int32, @max "5" limit int32} -> {[]Ticket, error}
    }

----

Transforms to:

[source,xml]
----
<root>
    A Ticket represents a piece of
    paper with things to do.
    <struct>
        <Ticket>
            ID is the unique identifier.
            <ID>uuid</ID>

            Message contains some text to read.
            <Message>string</Message>
        </Ticket>
    </struct>

    ... provides CRUD access functions for #ref{Ticket} entities.
    <interface>
        <Repository>
            ...selects a single entry.
            <FindOne>
                <id>uuid</id>
            </FindOne>
            <RETURNS> <!-- #-> -->
                <Ticket/>
                <error/>
            </RETURNS>

            ...searches all the things.
            <FindAll>
                <offset>int32</offset>
                <limit>int32</limit>
            </FindAll>
             <RETURNS> <!-- #-> -->
                <SLICE> <!-- [] -->
                    <Ticket/>
                </SLICE>
                <error/>
            </RETURNS>
        </Repository>
    </interface>

    <interface info="this is a forward attribute and never inline block as the other parser does">
        ...switch the parser
        <Repository2>
            ...selects a single entry.
            <param><limit>indicates some limit</limit></param>
            <FindAll>
                <offset><int32/></offset>
                <limit max="5"><int32/></limit>
            </FindAll>

            <RETURNS> <!-- #-> -->
                <SLICE> <!-- [] -->
                    <Ticket/>
                </SLICE>
                <error/>
            </RETURNS>

        </Repository2>
    </interface>
</root>
----


### Brainstorming 1

Incompatible attribute notation, where the attributes value can contain other nodes as well => attributes is a unique
section of key=value stuff (the json/yaml compatible part?). The nested node stuff is the xml-only part?

[source]
----
#!
@doc "...is the \"type\" documentation"
type Person struct {
    @doc "...is the first name"
    @param ????
    Firstname int32
}
----

[source,xml]
----
<type doc="...is the &quot;type&quot; documentation">
    <Person>
        <struct>
            <Firstname doc="...is the first name">
                <int32/>
            </Firstname>
        </struct>
    </Person>
</type>
----

